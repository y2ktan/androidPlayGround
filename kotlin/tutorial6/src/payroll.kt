//Final and private class
class A private constructor() {

}

//Singleton
object B {

}

//Not final class
open class C(val name: String, val age: Int) {
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (other !is C) return false

        if (name != other.name) return false
        if (age != other.age) return false

        return true
    }

    override fun hashCode(): Int {
        var result = name.hashCode()
        result = 31 * result + age
        return result
    }
}

//JAVA style overload constructor
class D : C {
    constructor(name: String) : this(name, 0)
    constructor(name: String, age: Int) : super(name, age)
}

class E(val n: String, val a: Int = 0) : C(n, a) {
    var address: String = "unspecified"
        set(value: String) {
            //field is a backing field
            field = value
        }

    var nationality: String = "MALAYSIAN"
        private set

    fun doSomething() {
        nationality = "America"
    }
}

data class F(val name: String, val age: Int = 0) {
    //equal, hashcode and copy is generated by default
//    fun copy(name:String=this.name, age: Int= this.age):F {
//        return F(name, age)
//    }

}

fun sum(a: Int, b: Int): Int = a + b

fun playWithEquality() {
    val func: (Int, Int) -> Int = ::sum

    val func2: (Int, Int) -> Int = { a: Int, b: Int -> a + b }
    val func3 = { a: Int, b: Int -> a + b }
    val func4: (Int, Int) -> Int = { a, b -> a + b }

}

fun doSomething(talent: Int): () -> String {
//    fun doDancing() ="Do dancing"
//    fun doSinging() = "Do singing"
//    return if (talent == 0) ::doDancing else ::doSinging

    val doDancing = {"Do dancing"}
    val doSinging = {"Do singing"}

    return if (talent == 0) doDancing else doSinging
}

fun printWithLambda(){
    {println(42)}()
    run {println(42)}
}

data class Person(val name:String, val age: Int)

fun lambdaList(){
    // numbers= [1,2,3,4,5,6]
    // square = [n * n for n in numbers]
    // squares_of_even = list(filter(lambda x: x%2==0, [n * n for n in numbers]))
    // squares_of_even = [n * n for n in numbers if n % 2 == 0]
    val numbers = listOf(1,2,3,4,5,6,7,8,9)
    val squares = numbers.map{it*it}
    //filter then map
    val squaresOfEven = numbers.map{it*it}.filter { it % 2 == 0 }
    println("\nmethod: ${object{}.javaClass.enclosingMethod.name}")
    println("square of even: $squaresOfEven")
    println("method 2")

    val squaresOfEven2 = numbers.asSequence().map{it*it}.filter { it % 2 == 0 }.toList()
    println("square of even2: $squaresOfEven2")
}

fun iteratorLoop(){
    // numbers= [1,2,3,4,5,6]
    // iterator = iter(numbers)
    // print(next(iterator))
    println("\nmethod: ${object{}.javaClass.enclosingMethod.name}")
    val numbers = listOf(1,2,3,4,5,6,7,8,9)
    val iterator = numbers.withIndex()
    for(item in iterator){
        println(item)
    }
}

fun allAnyCountField(){
    val numbers = listOf(1,2,3)
    println("\nmethod: ${object{}.javaClass.enclosingMethod.name}")
    println(!numbers.all{it==3})
    println(numbers.any{it>3})
}

fun groupByAge(){
    println("\nmethod: ${object{}.javaClass.enclosingMethod.name}")
    val people = listOf(Person("Bob", 60),Person("John", 60), Person("Ang", 18))
    println(people.groupBy { it.age })
}

fun getEldestPerson(){

    val people = listOf(Person("Tan", 38),Person("Ang", 30))
    //val max = people.maxBy { it.age }
    //Trailing lambda
    //val max = people.maxBy { p:Person->p.age }

    //list<Person>.maxBy(predicate:(Person)->Int)
    val max = people.maxBy ({ p:Person->p.age })
    println("${max?.name}: ${max?.age}")
}

fun List<Person>.max(predicate:(p:Person)->Boolean): Person?{
    println("\nmethod: ${object{}.javaClass.enclosingMethod.name}")
    var theOldest:Person? = null
    for(p in this) {
        if (predicate(p)) {
            theOldest = p
        }
    }
    return theOldest
}

//Functions?
//Function is a First Class Citizen
//1. It can be assigend a value
//2. It can be passed to function
//3. It can be returned from function

//Pure function
//First class citizens and (Inputs, output) will be invariant


//Pure function (should be stateless)
//val outer = "FOO" (making function become stateful
fun String.filter(predicate:(Char) -> Boolean):String {
    println("\nmethod: ${object{}.javaClass.enclosingMethod.name}")
    //We are preserving immutability ... sequence should immutable
    val sb = StringBuilder()
    for(index in 0 until length){
        val element = get(index)
        if (predicate(element)) sb.append(element)
    }

    //if(outer.length > 0) sb.append("Things")
    //println("somethin") --> stateful
    return sb.toString()
}


data class Person2(val first:String, val last:String)

fun safeCastAs(){
    println("\nmethod: ${object{}.javaClass.enclosingMethod.name}")
    val p1 = Person2("Dimitry", "Jemerov")
    val p2 = Person2("Dimitry", "Jemerov")
    println(p1==p2)
    println(p1.equals(42))

}

fun playWithStringBuilder(){
    println("ab1c".filter { it in 'a' until 'z' })
}

fun performRequest(url:String,
                   callback:(code:Int, content:String) -> Unit){

}
val processLoginUrl = {code:Int, content:String -> /*...*/ }
fun performRequestFuction(){
    val url = "http://kotlin"
    performRequest(url){code, content -> /*...*/ }
    performRequest(url){code, page -> /*...*/ }
    performRequest(url, processLoginUrl)
}

fun fail(message:String): Nothing{
    throw IllegalStateException(message)
}

data class Point(val x:Int, val y: Int){
    operator  fun plus(other:Point):Point{
        return Point(x + other.x, y + other.y)
    }
}

fun sequence(){
    println("\nmethod: ${object{}.javaClass.enclosingMethod.name}")
    val numbers = listOf(10,21,32,43,56)
    for(n in numbers){
        println(n)
    }

    for((index, number) in numbers.withIndex()){
        println("$index: $number")
    }
}

operator fun Point.minus(y: Int): Int{
    return this - y
}



fun main(args: Array<String>) {
    val somemore = ::doSomething
    println(doSomething(0)())
    getEldestPerson()
    lambdaList()
    iteratorLoop()
    allAnyCountField()
    groupByAge()
    playWithStringBuilder()
    safeCastAs()
    sequence()
}